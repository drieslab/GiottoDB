% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spatial_chunking.R
\name{chunkSpatApply}
\alias{chunkSpatApply}
\alias{chunkSpatApplyPoly}
\alias{chunkSpatApplyPoints}
\title{Apply a function over spatially chunked data}
\usage{
chunkSpatApplyPoly(
  x = NULL,
  y = NULL,
  chunk_y = TRUE,
  fun,
  extent = NULL,
  n_per_chunk = getOption("gdb.nperchunk", 1e+05),
  remote_name = NULL,
  progress = TRUE,
  ...
)

chunkSpatApplyPoints(
  x = NULL,
  y = NULL,
  chunk_y = TRUE,
  fun,
  extent = NULL,
  n_per_chunk = getOption("gdb.nperchunk", 1e+05),
  remote_name = NULL,
  progress = TRUE
)
}
\arguments{
\item{x}{dbPolygonProxy or dbPointsProxy}

\item{y}{missing/null if not needed. Otherwise accepts a dbPolygonProxy or
dbPointsProxy object}

\item{chunk_y}{(default = TRUE) whether y also needs to be spatially chunked
if it is provided.}

\item{fun}{function to apply}

\item{extent}{spatial extent of data to apply across. Defaults to the extent
of \code{x} if not given}

\item{n_per_chunk}{(default is 1e5) number of records to try to process per chunk.
This value can be set globally using options(gdb.nperchunk = ?)}

\item{remote_name}{name to assign the result in the database. Defaults to a
generic incrementing 'gdb_nnn' if not given}

\item{progress}{whether to plot the progress}

\item{...}{additional params to pass to GiottoDB object creation}
}
\value{
dbPolygonProxy or dbPointsProxy
}
\description{
Split a function operation into multiple spatial chunks. Results are appended
back into the database as a new table. This is not parallelized as some databases
do not work with parallel writes, but are more performant with large single
chunks of data. The functions that are provided, however, can be parallelized
in their processing after the chunk has been pulled into memory and only needs
to be combined into one before being written.
}
